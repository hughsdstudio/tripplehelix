<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Temporalities & Epistemic Mutations</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #fafafa;
            overflow-x: auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .title {
            font-size: 3rem;
            font-weight: bold;
            color: #141416;
            margin: 0;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #787882;
            margin: 5px 0 20px 0;
            font-style: italic;
        }
        
        .container {
            display: flex;
            gap: 20px;
            max-width: 1900px;
            margin: 0 auto;
        }
        
        .sidebar {
            flex: 0 0 320px;
            font-size: 0.85rem;
            line-height: 1.3;
        }
        
        .section {
            margin-bottom: 20px;
        }
        
        .section h3 {
            font-size: 1rem;
            font-weight: bold;
            color: #141416;
            margin: 0 0 6px 0;
        }
        
        .section p {
            margin: 0 0 8px 0;
            color: #2a2a2e;
        }
        
        .legend {
            border-top: 2px solid #787882;
            padding-top: 12px;
        }
        
        .reset-button {
            background: #0064b4;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            margin-bottom: 12px;
        }
        
        .reset-button:hover {
            background: #004d8c;
        }
        
        .instructions {
            font-size: 0.75rem;
            color: #525257;
            font-style: italic;
            margin-bottom: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 8px;
        }
        
        .diagram-container {
            flex: 1;
            position: relative;
        }
        
        #network {
            border: 1px solid #ddd;
            background: white;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .diagram-container {
            overflow: hidden;
            touch-action: pan-x pan-y;
        }
        
        .node-quadrant {
            fill: none;
            stroke: #141416;
            stroke-width: 3;
            stroke-dasharray: 10,5;
            cursor: pointer;
        }
        
        .node-temporal {
            fill: none;
            stroke: #141416;
            stroke-width: 2;
            stroke-dasharray: 5,3;
            cursor: pointer;
        }
        
        .node-epistemic {
            fill: none;
            stroke: #141416;
            stroke-width: 2;
            stroke-dasharray: 8,4,2,4;
            cursor: pointer;
        }
        
        .node-recursive {
            fill: none;
            stroke: #141416;
            stroke-width: 2;
            stroke-dasharray: 3,6;
            cursor: pointer;
        }
        
        .node-anticapture {
            fill: none;
            stroke: #141416;
            stroke-width: 2;
            stroke-dasharray: 12,3,3,3;
            cursor: pointer;
        }
        
        .node-engine {
            fill: none;
            stroke: #141416;
            stroke-width: 4;
            cursor: pointer;
        }
        
        .node:hover {
            stroke-width: 3;
        }
        
        .node-text {
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
        }
        
        .node-text-large {
            font-size: 11px;
            font-weight: bold;
        }
        
        .node-text-engine {
            font-size: 18px;
            font-weight: bold;
        }
        
        .link-temporal {
            stroke: #141416;
            stroke-dasharray: 5,3;
            fill: none;
        }
        
        .link-epistemic {
            stroke: #141416;
            stroke-dasharray: 8,4,2,4;
            fill: none;
        }
        
        .link-recursive {
            stroke: #141416;
            stroke-dasharray: 3,6;
            fill: none;
        }
        
        .link-anticapture {
            stroke: #141416;
            stroke-dasharray: 12,3,3,3;
            fill: none;
        }
        
        .link-connection {
            stroke: #141416;
            stroke-opacity: 0.4;
            stroke-dasharray: 1,3;
            fill: none;
        }
        
        .axis-line {
            stroke: #141416;
            stroke-width: 1.5;
            marker-end: url(#arrowhead);
        }
        
        .axis-label {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            fill: #141416;
        }
        
        .quadrant-label {
            font-size: 14px;
            font-weight: bold;
            text-anchor: middle;
            fill: #525257;
            opacity: 0.7;
        }
        
        .grid-line {
            stroke: #525257;
            stroke-opacity: 0.2;
            stroke-width: 1;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">Recursive Temporalities</h1>
        <div class="subtitle">Epistemic Mutations & Anti-Capture Strategies</div>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h3>Framework</h3>
                <p>This diagram maps the recursive dynamics between temporal regimes, epistemic mutations, and strategies of capture/commons across technological paradigms. Each quadrant represents a distinct but interconnected domain of analysis.</p>
            </div>
            
            <div class="section">
                <h3>Temporal Regimes</h3>
                <p>How steam, cybernetic, and computational eras create distinct temporalities. "The steam engine forced a revolution in the very concept of work and energy." From thermodynamic cycles to predictive futures.</p>
            </div>
            
            <div class="section">
                <h3>Epistemic Mutations</h3>
                <p>Technologies as epistemic infrastructures. "Because he didn't have a formula for it, because he came before the steam engine." Each paradigm reshapes what counts as knowledge.</p>
            </div>
            
            <div class="section">
                <h3>Recursivity Problem</h3>
                <p>"Where does recursion begin? The cause is the totality of the loop." How circular causation replaces linear explanation in understanding sociotechnical systems.</p>
            </div>
            
            <div class="section">
                <h3>Anti-Capture Strategies</h3>
                <p>Commons vs enclosure dynamics. "When residues are enclosed by platforms, the cultural cycle suffers metabolic rift." Strategies for keeping knowledge circulating.</p>
            </div>
            
            <div class="legend">
                <h3>Controls</h3>
                <button class="reset-button" onclick="resetAllNodes()">Reset Layout</button>
                <button class="reset-button" onclick="exportText()" style="margin-left: 8px;">Export Text</button>
                <div class="instructions">
                    • Drag nodes to position them<br>
                    • Double-click to unlock nodes<br>
                    • Nodes lock when moved<br>
                    • Export creates .txt file with all content
                </div>
                
                <h3>Legend</h3>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 5px, transparent 5px, transparent 8px);"></div>
                    <span>temporal flows (short dash)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 8px, transparent 8px, transparent 12px, black 12px, black 14px, transparent 14px, transparent 18px);"></div>
                    <span>epistemic shifts (dash-dot-dash)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 3px, transparent 3px, transparent 9px);"></div>
                    <span>recursive loops (short dash, long gap)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 12px, transparent 12px, transparent 15px, black 15px, black 18px, transparent 18px, transparent 21px, black 21px, black 24px, transparent 24px, transparent 27px);"></div>
                    <span>anti-capture (long-short-short)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 1px, transparent 1px, transparent 4px);"></div>
                    <span>weak connections (dots)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="border: 2px solid black;"></div>
                    <span>engine (solid thick)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 10px, transparent 10px, transparent 15px);"></div>
                    <span>quadrant labels (medium dash)</span>
                </div>
            </div>
        </div>
        
        <div class="diagram-container">
            <svg id="network" width="1400" height="1000"></svg>
            <div style="margin-top: 12px; font-size: 0.8rem; color: #525257; font-style: italic; max-width: 1400px;">
                <p>Each node contains substantial text from the source documents. The diagram reveals how temporal regimes, epistemic frameworks, recursive processes, and capture/commons dynamics form an interconnected system of historical analysis. <strong>Drag nodes to explore relationships and create custom arrangements.</strong></p>
            </div>
        </div>
    </div>

    <script>
        // Network data structure with longer text content
        const data = {
            nodes: [
                // Central engine
                { id: "engine", label: "RECURSIVE\nHISTORY", type: "engine", group: "center", quadrant: "center" },
                
                // Quadrant Labels
                { id: "temporal_label", label: "TEMPORAL REGIMES", type: "quadrant", group: "top-left", quadrant: "temporal" },
                { id: "epistemic_label", label: "EPISTEMIC MUTATIONS", type: "quadrant", group: "top-right", quadrant: "epistemic" },
                { id: "recursive_label", label: "RECURSIVITY PROBLEM", type: "quadrant", group: "bottom-left", quadrant: "recursive" },
                { id: "anticapture_label", label: "ANTI-CAPTURE STRATEGIES", type: "quadrant", group: "bottom-right", quadrant: "anticapture" },
                
                // TEMPORAL REGIMES (Top-Left Quadrant)
                { id: "steam_era", label: "Steam era: 'Because he didn't have a formula for it, because he came before the steam engine. The era of the steam engine and administrative balance-sheets were needed for us to ask: what does a machine yield?'", type: "temporal", group: "top-left", quadrant: "temporal" },
                
                { id: "thermodynamic_time", label: "Thermodynamic cycles: 'Maximum efficiency demands reversibility that no real engine attains. History flirts with reversibility in myths of restoration, yet every cycle completes with hysteresis.'", type: "temporal", group: "top-left", quadrant: "temporal" },
                
                { id: "cybernetic_era", label: "Cybernetic shift: 'With information theory, we discovered that entropy is not thermodynamical, but statistical. The machine is the relational process at play.'", type: "temporal", group: "top-left", quadrant: "temporal" },
                
                { id: "computational_crisis", label: "Computational temporality: 'The future arrives before the present. Predictive systems and financial instruments craft today out of tomorrow, preempting what has not yet occurred.'", type: "temporal", group: "top-left", quadrant: "temporal" },
                
                { id: "presentism", label: "Regime of presentism: 'The horizon of expectation contracts into a permanent now, history and future alike subordinated to an eternal present tense.'", type: "temporal", group: "top-left", quadrant: "temporal" },
                
                { id: "occupation_time", label: "Work as occupation: 'Activity without ends, continuous absorption that suspends the distinction between labor and leisure, between production and display.'", type: "temporal", group: "top-left", quadrant: "temporal" },
                
                // EPISTEMIC MUTATIONS (Top-Right Quadrant)
                { id: "steam_episteme", label: "Steam's conceptual revolution: 'The steam engine forced a revolution in the very concept of work and energy, expanding definition from simple mechanics to universal principle of thermodynamics.'", type: "epistemic", group: "top-right", quadrant: "epistemic" },
                
                { id: "freud_machine", label: "Psyche as steam engine: 'Freud's whole discussion revolves around that question: what, in terms of energy, is the psyche? The mind became a pressure system—drives, repression, release.'", type: "epistemic", group: "top-right", quadrant: "epistemic" },
                
                { id: "lacan_language", label: "Language as machine: 'The unconscious concerns the living dynamic of language itself, and language can be thought of as a literal machine. What we call unconscious is language.'", type: "epistemic", group: "top-right", quadrant: "epistemic" },
                
                { id: "infrastructure_pedagogy", label: "Technologies teach: 'Technologies teach us how to imagine ourselves. The boiler gives us the energetic unconscious; statistical engines sponsor a subject of prediction and prompt.'", type: "epistemic", group: "top-right", quadrant: "epistemic" },
                
                { id: "razi_distinction", label: "Al-Razi's epistemology: 'We can know that a techne like the steam engine transforms society (general knowledge), but cannot fully know what it is in its totality without ethical deliberation.'", type: "epistemic", group: "top-right", quadrant: "epistemic" },
                
                { id: "suhrawardi_illumination", label: "Suhrawardi's paths: 'There are two paths: reasoning and reading of signs, and a direct way whereby truth illuminates us through mystical experience, where subject, object, and knowledge coincide.'", type: "epistemic", group: "top-right", quadrant: "epistemic" },
                
                // RECURSIVITY PROBLEM (Bottom-Left Quadrant)
                { id: "recursion_beginning", label: "Circular causation: 'Where does recursion begin? The search for the beginning is a search for first cause. In a circular loop, the beginning is only temporal. The cause is the totality of the loop.'", type: "recursive", group: "bottom-left", quadrant: "recursive" },
                
                { id: "spiral_process", label: "Recursivity as spiral: 'Recursivity ought to be understood not as mere repetition, but as a process of reflexivity in which contingency might emerge and create singularities.'", type: "recursive", group: "bottom-left", quadrant: "recursive" },
                
                { id: "triple_helix_mutation", label: "Systemic reconfiguration: 'A generative mutation in one strand inevitably forces a reconfiguration of the others. The steam engine forced society and nature to be reconceived through thermodynamic lens.'", type: "recursive", group: "bottom-left", quadrant: "recursive" },
                
                { id: "actual_before_conceptual", label: "Technology precedes theory: 'The engine was actual before becoming conceptual. Technics made what science later came to better understand. The world became thermodynamical before knowing so.'", type: "recursive", group: "bottom-left", quadrant: "recursive" },
                
                { id: "helical_cycles", label: "Historical hysteresis: 'Cycles remain, but they are helical cycles—recurrences displaced along an axis of irretrievable transformation. The path back is not the path out.'", type: "recursive", group: "bottom-left", quadrant: "recursive" },
                
                { id: "entropy_constitution", label: "Waste as constitutive: 'No conversion is free. Entropy is not afterthought: waste heat is constitutive. Each historical advance generates its externalities—the helix advances by spending itself.'", type: "recursive", group: "bottom-left", quadrant: "recursive" },
                
                // ANTI-CAPTURE STRATEGIES (Bottom-Right Quadrant)
                { id: "metabolic_rift", label: "Metabolic rift: 'When residues are enclosed by platforms, IP regimes, or markets, the cultural cycle suffers metabolic rift: outputs no longer fertilize collective reasoning.'", type: "anticapture", group: "bottom-right", quadrant: "anticapture" },
                
                { id: "return_vector", label: "Return vs capture: 'The metabolic force of artistic residue depends on its return vector to the general intellect. Anti-capture design keeps residues circulating as public nutrients.'", type: "anticapture", group: "bottom-right", quadrant: "anticapture" },
                
                { id: "nomadic_sedentary", label: "Nomadic vs sedentary: 'Nomadic epistemology is characterized by fluidity, alterity, customary knowledge. Sedentary paradigm is founded on archives, fixed identities, state control, universal reason.'", type: "anticapture", group: "bottom-right", quadrant: "anticapture" },
                
                { id: "open_processes", label: "Protocol transparency: 'Open processes, composable toolchains, provenance credentials that block commodification while preserving pedagogy become integral to inhuman labor itself.'", type: "anticapture", group: "bottom-right", quadrant: "anticapture" },
                
                { id: "recollective_rationality", label: "Recollective media: 'What if technological assemblage were engineered not merely to store memory, but to structure it as tool for reason? History as propositions to be rationally reconstructed.'", type: "anticapture", group: "bottom-right", quadrant: "anticapture" },
                
                { id: "leaks_matter", label: "Productive leaks: 'Engines leak: heat, steam, noise, time. Some of most consequential innovations are re-routings of the leak—capturing waste heat, revaluing idleness as study.'", type: "anticapture", group: "bottom-right", quadrant: "anticapture" }
            ],
            
            links: [
                // Temporal flows (orange dashed)
                { source: "steam_era", target: "cybernetic_era", type: "temporal" },
                { source: "cybernetic_era", target: "computational_crisis", type: "temporal" },
                { source: "computational_crisis", target: "presentism", type: "temporal" },
                { source: "presentism", target: "occupation_time", type: "temporal" },
                { source: "thermodynamic_time", target: "helical_cycles", type: "temporal" },
                
                // Epistemic shifts (purple dashed)
                { source: "steam_episteme", target: "freud_machine", type: "epistemic" },
                { source: "freud_machine", target: "lacan_language", type: "epistemic" },
                { source: "lacan_language", target: "infrastructure_pedagogy", type: "epistemic" },
                { source: "razi_distinction", target: "suhrawardi_illumination", type: "epistemic" },
                { source: "steam_episteme", target: "razi_distinction", type: "epistemic" },
                
                // Recursive loops (green dash-dot)
                { source: "recursion_beginning", target: "spiral_process", type: "recursive" },
                { source: "spiral_process", target: "triple_helix_mutation", type: "recursive" },
                { source: "actual_before_conceptual", target: "steam_era", type: "recursive" },
                { source: "triple_helix_mutation", target: "entropy_constitution", type: "recursive" },
                { source: "helical_cycles", target: "recursion_beginning", type: "recursive" },
                
                // Anti-capture resistance (red dashed)
                { source: "metabolic_rift", target: "return_vector", type: "anticapture" },
                { source: "return_vector", target: "open_processes", type: "anticapture" },
                { source: "nomadic_sedentary", target: "recollective_rationality", type: "anticapture" },
                { source: "leaks_matter", target: "entropy_constitution", type: "anticapture" },
                { source: "open_processes", target: "leaks_matter", type: "anticapture" },
                
                // Cross-quadrant connections (weak gray)
                { source: "engine", target: "recursion_beginning", type: "connection" },
                { source: "engine", target: "steam_episteme", type: "connection" },
                { source: "engine", target: "computational_crisis", type: "connection" },
                { source: "engine", target: "return_vector", type: "connection" },
                
                // Inter-quadrant flows
                { source: "steam_era", target: "steam_episteme", type: "connection" },
                { source: "actual_before_conceptual", target: "steam_episteme", type: "connection" },
                { source: "infrastructure_pedagogy", target: "computational_crisis", type: "connection" },
                { source: "occupation_time", target: "metabolic_rift", type: "connection" },
                { source: "entropy_constitution", target: "leaks_matter", type: "connection" },
                { source: "suhrawardi_illumination", target: "nomadic_sedentary", type: "connection" }
            ]
        };

        // Set up SVG with anti-zoom measures
        const svg = d3.select("#network");
        const width = +svg.attr("width");
        const height = +svg.attr("height");

        // Prevent zoom behaviors
        svg.on("wheel", function(event) {
            event.preventDefault();
            event.stopPropagation();
        });
        
        svg.on("dblclick", function(event) {
            event.preventDefault();
            event.stopPropagation();
        });

        // Create arrow markers
        svg.append("defs").append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 8)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#141416");

        // Create main container group
        const mainGroup = svg.append("g").attr("class", "main-container");

        // Add quadrant dividers
        mainGroup.append("line")
            .attr("class", "axis-line")
            .attr("x1", width/2).attr("y1", 50)
            .attr("x2", width/2).attr("y2", height-50);
            
        mainGroup.append("line")
            .attr("class", "axis-line")
            .attr("x1", 50).attr("y1", height/2)
            .attr("x2", width-50).attr("y2", height/2);

        // Add quadrant labels
        mainGroup.append("text")
            .attr("class", "quadrant-label")
            .attr("x", width/4)
            .attr("y", 30)
            .text("TEMPORAL REGIMES");
            
        mainGroup.append("text")
            .attr("class", "quadrant-label")
            .attr("x", 3*width/4)
            .attr("y", 30)
            .text("EPISTEMIC MUTATIONS");
            
        mainGroup.append("text")
            .attr("class", "quadrant-label")
            .attr("x", width/4)
            .attr("y", height-20)
            .text("RECURSIVITY PROBLEM");
            
        mainGroup.append("text")
            .attr("class", "quadrant-label")
            .attr("x", 3*width/4)
            .attr("y", height-20)
            .text("ANTI-CAPTURE STRATEGIES");

        // Create force simulation with quadrant positioning and dynamic collision
        const simulation = d3.forceSimulation(data.nodes)
            .force("link", d3.forceLink(data.links).id(d => d.id).distance(140))
            .force("charge", d3.forceManyBody().strength(-400))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(d => Math.max(d.textWidth, d.textHeight) / 2 + 10))
            .force("x", d3.forceX(d => {
                if (d.quadrant === "temporal") return width/4;
                if (d.quadrant === "epistemic") return 3*width/4;
                if (d.quadrant === "recursive") return width/4;
                if (d.quadrant === "anticapture") return 3*width/4;
                return width/2;
            }).strength(0.3))
            .force("y", d3.forceY(d => {
                if (d.quadrant === "temporal") return height/4;
                if (d.quadrant === "epistemic") return height/4;
                if (d.quadrant === "recursive") return 3*height/4;
                if (d.quadrant === "anticapture") return 3*height/4;
                return height/2;
            }).strength(0.3));

        // Add links
        const link = mainGroup.append("g")
            .selectAll("path")
            .data(data.links)
            .enter().append("path")
            .attr("class", d => `link-${d.type}`)
            .attr("stroke-width", 1.5);

        // Add nodes
        const node = mainGroup.append("g")
            .selectAll("g")
            .data(data.nodes)
            .enter().append("g")
            .attr("class", "node")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // Function to estimate text dimensions
        function estimateTextDimensions(text, fontSize, maxWidth) {
            const words = text.split(' ');
            const avgCharWidth = fontSize * 0.6; // Approximate character width
            const lineHeight = fontSize * 1.2;
            
            let lines = [];
            let currentLine = '';
            
            for (let word of words) {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                if (testLine.length * avgCharWidth <= maxWidth) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);
            
            const width = Math.min(maxWidth, Math.max(...lines.map(line => line.length * avgCharWidth)));
            const height = lines.length * lineHeight;
            
            return { width, height, lines };
        }

        // Add data for text dimensions to nodes
        data.nodes.forEach(d => {
            let fontSize, maxWidth;
            if (d.type === "engine") {
                fontSize = 14;
                maxWidth = 120;
            } else if (d.type === "quadrant") {
                fontSize = 12;
                maxWidth = 160;
            } else {
                fontSize = 9;
                maxWidth = 300;
            }
            
            const dimensions = estimateTextDimensions(d.label, fontSize, maxWidth);
            d.textWidth = dimensions.width + 20; // 10px padding each side
            d.textHeight = dimensions.height + 20; // 10px padding top/bottom
        });

        // Add rectangles for nodes with dynamic sizing
        node.append("rect")
            .attr("width", d => d.textWidth)
            .attr("height", d => d.textHeight)
            .attr("x", d => -d.textWidth/2)
            .attr("y", d => -d.textHeight/2)
            .attr("rx", 8)
            .attr("ry", 8)
            .attr("class", d => `node-${d.type}`);

        // Add text labels with better positioning for rectangles
        node.append("foreignObject")
            .attr("width", d => d.textWidth - 10)
            .attr("height", d => d.textHeight - 10)
            .attr("x", d => -(d.textWidth-10)/2)
            .attr("y", d => -(d.textHeight-10)/2)
            .append("xhtml:div")
            .style("width", "100%")
            .style("height", "100%")
            .style("display", "flex")
            .style("align-items", "center")
            .style("justify-content", "center")
            .style("text-align", "center")
            .style("font-size", d => d.type === "engine" ? "14px" : d.type === "quadrant" ? "12px" : "9px")
            .style("font-weight", d => d.type === "engine" || d.type === "quadrant" ? "bold" : "normal")
            .style("line-height", "1.2")
            .style("overflow", "hidden")
            .style("padding", "5px")
            .style("box-sizing", "border-box")
            .html(d => d.label.replace(/\n/g, '<br>'));

        // Update positions on simulation tick
        simulation.on("tick", () => {
            // Keep nodes within bounds
            data.nodes.forEach(d => {
                d.x = Math.max(50, Math.min(width - 50, d.x));
                d.y = Math.max(50, Math.min(height - 50, d.y));
            });
            
            link.attr("d", d => {
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const dr = Math.sqrt(dx * dx + dy * dy) * 1.2;
                return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
            });

            node.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Drag functions
        function dragstarted(event, d) {
            event.sourceEvent.stopPropagation();
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            event.sourceEvent.stopPropagation();
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            event.sourceEvent.stopPropagation();
            if (!event.active) simulation.alphaTarget(0);
            // Visual feedback
            d3.select(event.sourceEvent.target.parentNode).select("rect")
                .style("stroke", "#14aa8c").transition().duration(500).style("stroke", null);
        }

        // Global function to reset all nodes
        window.resetAllNodes = function() {
            data.nodes.forEach(d => {
                d.fx = null;
                d.fy = null;
            });
            simulation.alphaTarget(0.3).restart();
            
            // Visual feedback
            node.selectAll("rect").style("stroke", "#ff6b6b")
                .transition().duration(1000).style("stroke", null);
        };

        // Global function to export text content
        window.exportText = function() {
            // Define quadrant order (clockwise from top-right)
            const quadrantOrder = ['epistemic', 'anticapture', 'recursive', 'temporal'];
            const quadrantNames = {
                'epistemic': 'EPISTEMIC MUTATIONS',
                'anticapture': 'ANTI-CAPTURE STRATEGIES', 
                'recursive': 'RECURSIVITY PROBLEM',
                'temporal': 'TEMPORAL REGIMES'
            };

            let textContent = "RECURSIVE TEMPORALITIES: EPISTEMIC MUTATIONS & ANTI-CAPTURE STRATEGIES\n";
            textContent += "=" + "=".repeat(70) + "\n\n";
            textContent += "Framework: This document maps the recursive dynamics between temporal regimes, epistemic mutations, and strategies of capture/commons across technological paradigms. Each section represents a distinct but interconnected domain of analysis.\n\n";

            // Process each quadrant in clockwise order
            quadrantOrder.forEach(quadrant => {
                const quadrantNodes = data.nodes.filter(d => d.quadrant === quadrant && d.type !== 'quadrant');
                
                if (quadrantNodes.length > 0) {
                    textContent += quadrantNames[quadrant] + "\n";
                    textContent += "-".repeat(quadrantNames[quadrant].length) + "\n\n";
                    
                    quadrantNodes.forEach((node, index) => {
                        // Clean up the text - remove HTML breaks and extra whitespace
                        const cleanText = node.label
                            .replace(/\n/g, ' ')
                            .replace(/\s+/g, ' ')
                            .trim();
                        
                        textContent += `${index + 1}. ${cleanText}\n\n`;
                    });
                    
                    textContent += "\n";
                }
            });

            // Add footer with current date
            const currentDate = new Date().toLocaleDateString();
            textContent += "\n" + "-".repeat(70) + "\n";
            textContent += `Exported from Recursive Temporalities Diagram on ${currentDate}\n`;
            textContent += "Interactive diagram available at: [URL where hosted]\n";

            // Create and download file
            const blob = new Blob([textContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'recursive_temporalities_text_export.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Visual feedback
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'Exported!';
            button.style.background = '#14aa8c';
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '#0064b4';
            }, 2000);
        };

        // Add hover effects and double-click to unlock
        node.on("mouseover", function(event, d) {
            d3.select(this).select("rect").style("stroke-width", "3px");
        })
        .on("mouseout", function(event, d) {
            d3.select(this).select("rect").style("stroke-width", null);
        })
        .on("dblclick", function(event, d) {
            event.stopPropagation();
            d.fx = null;
            d.fy = null;
            simulation.alphaTarget(0.3).restart();
            
            const rect = d3.select(this).select("rect");
            rect.style("stroke", "#ff6b6b").transition().duration(500).style("stroke", null);
        });

        // Additional protection against zoom
        document.addEventListener('wheel', function(e) {
            if (e.target.closest('#network')) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
