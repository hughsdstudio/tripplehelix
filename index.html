<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Temporalities & Epistemic Mutations</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #fafafa;
            overflow-x: auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .title {
            font-size: 3rem;
            font-weight: bold;
            color: #141416;
            margin: 0;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #787882;
            margin: 5px 0 20px 0;
            font-style: italic;
        }
        
        .container {
            display: flex;
            gap: 20px;
            max-width: 1900px;
            margin: 0 auto;
        }
        
        .sidebar {
            flex: 0 0 320px;
            font-size: 0.85rem;
            line-height: 1.3;
        }
        
        .section {
            margin-bottom: 20px;
        }
        
        .section h3 {
            font-size: 1rem;
            font-weight: bold;
            color: #141416;
            margin: 0 0 6px 0;
        }
        
        .section p {
            margin: 0 0 8px 0;
            color: #2a2a2e;
        }
        
        .legend {
            border-top: 2px solid #787882;
            padding-top: 12px;
        }
        
        .reset-button {
            background: #0064b4;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            margin-bottom: 12px;
            margin-right: 8px;
        }
        
        .reset-button:hover {
            background: #004d8c;
        }
        
        .instructions {
            font-size: 0.75rem;
            color: #525257;
            font-style: italic;
            margin-bottom: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 8px;
        }
        
        .diagram-container {
            flex: 1;
            position: relative;
        }
        
        #network {
            border: 1px solid #ddd;
            background: white;
            touch-action: none;
            user-select: none;
            overflow: hidden;
        }
        
        .node {
            cursor: move;
        }
        
        .node-rect {
            fill: rgba(255, 255, 255, 0.1);
            stroke: #141416;
            stroke-width: 2;
            rx: 8;
            ry: 8;
        }
        
        .node-quadrant {
            stroke-dasharray: 10,5;
            stroke-width: 3;
        }
        
        .node-temporal {
            stroke-dasharray: 5,3;
        }
        
        .node-epistemic {
            stroke-dasharray: 8,4,2,4;
        }
        
        .node-recursive {
            stroke-dasharray: 3,6;
        }
        
        .node-anticapture {
            stroke-dasharray: 12,3,3,3;
        }
        
        .node-engine {
            stroke-width: 4;
            fill: rgba(240, 248, 255, 0.2);
        }
        
        .node:hover .node-rect {
            stroke-width: 3;
            fill: rgba(248, 248, 255, 0.3);
        }
        
        .node.dragging .node-rect {
            stroke: #14aa8c;
            stroke-width: 3;
            fill: rgba(232, 248, 245, 0.4);
        }
        
        .node-text {
            font-size: 9px;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            fill: #141416;
        }
        
        .node-text-large {
            font-size: 12px;
            font-weight: bold;
        }
        
        .node-text-engine {
            font-size: 14px;
            font-weight: bold;
        }
        
        .link {
            fill: none;
            stroke: #141416;
            stroke-width: 1.5;
        }
        
        .link-temporal {
            stroke-dasharray: 5,3;
        }
        
        .link-epistemic {
            stroke-dasharray: 8,4,2,4;
        }
        
        .link-recursive {
            stroke-dasharray: 3,6;
        }
        
        .link-anticapture {
            stroke-dasharray: 12,3,3,3;
        }
        
        .link-connection {
            stroke-opacity: 0.4;
            stroke-dasharray: 1,3;
        }
        
        .axis-line {
            stroke: #141416;
            stroke-width: 1.5;
        }
        
        .axis-label {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            fill: #141416;
        }
        
        .quadrant-label {
            font-size: 14px;
            font-weight: bold;
            text-anchor: middle;
            fill: #525257;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">Recursive Temporalities</h1>
        <div class="subtitle">Epistemic Mutations & Anti-Capture Strategies</div>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h3>Framework</h3>
                <p>This diagram maps the recursive dynamics between temporal regimes, epistemic mutations, and strategies of capture/commons across technological paradigms. Each quadrant represents a distinct but interconnected domain of analysis.</p>
            </div>
            
            <div class="section">
                <h3>Temporal Regimes</h3>
                <p>How steam, cybernetic, and computational eras create distinct temporalities. "The steam engine forced a revolution in the very concept of work and energy." From thermodynamic cycles to predictive futures.</p>
            </div>
            
            <div class="section">
                <h3>Epistemic Mutations</h3>
                <p>Technologies as epistemic infrastructures. "Because he didn't have a formula for it, because he came before the steam engine." Each paradigm reshapes what counts as knowledge.</p>
            </div>
            
            <div class="section">
                <h3>Recursivity Problem</h3>
                <p>"Where does recursion begin? The cause is the totality of the loop." How circular causation replaces linear explanation in understanding sociotechnical systems.</p>
            </div>
            
            <div class="section">
                <h3>Anti-Capture Strategies</h3>
                <p>Commons vs enclosure dynamics. "When residues are enclosed by platforms, the cultural cycle suffers metabolic rift." Strategies for keeping knowledge circulating.</p>
            </div>
            
            <div class="legend">
                <h3>Controls</h3>
                <button class="reset-button" onclick="resetAllNodes()">Reset Layout</button>
                <button class="reset-button" onclick="exportText()">Export Text</button>
                <div class="instructions">
                    • <strong>Drag nodes to position them</strong><br>
                    • Nodes stay where you place them<br>
                    • Export creates .txt file with arrangement
                </div>
                
                <h3>Legend</h3>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 5px, transparent 5px, transparent 8px);"></div>
                    <span>temporal flows (short dash)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 8px, transparent 8px, transparent 12px, black 12px, black 14px, transparent 14px, transparent 18px);"></div>
                    <span>epistemic shifts (dash-dot-dash)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 3px, transparent 3px, transparent 9px);"></div>
                    <span>recursive loops (short dash, long gap)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 12px, transparent 12px, transparent 15px, black 15px, black 18px, transparent 18px, transparent 21px, black 21px, black 24px, transparent 24px, transparent 27px);"></div>
                    <span>anti-capture (long-short-short)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 1px, transparent 1px, transparent 4px);"></div>
                    <span>weak connections (dots)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="border: 2px solid black;"></div>
                    <span>engine (solid thick)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: black; background-image: repeating-linear-gradient(90deg, black, black 10px, transparent 10px, transparent 15px);"></div>
                    <span>quadrant labels (medium dash)</span>
                </div>
            </div>
        </div>
        
        <div class="diagram-container">
            <svg id="network" width="1400" height="1000"></svg>
            <div style="margin-top: 12px; font-size: 0.8rem; color: #525257; font-style: italic; max-width: 1400px;">
                <p>Each node contains substantial text from the source documents. The diagram reveals how temporal regimes, epistemic frameworks, recursive processes, and capture/commons dynamics form an interconnected system of historical analysis. <strong>Drag nodes to explore relationships and create custom arrangements.</strong></p>
            </div>
        </div>
    </div>

    <script>
        // Data structure with expanded content nodes
        const nodes = [
            // Central engine
            { id: "engine", label: "RECURSIVE\nHISTORY", type: "engine", quadrant: "center", x: 700, y: 500 },
            
            // TEMPORAL REGIMES (Top-Left Quadrant)
            { id: "steam_era", label: "Steam era: 'Because he didn't have a formula for it, because he came before the steam engine. The era of the steam engine and administrative balance-sheets were needed for us to ask: what does a machine yield?'", type: "temporal", quadrant: "temporal", x: 250, y: 150 },
            
            { id: "thermodynamic_time", label: "Thermodynamic cycles: 'Maximum efficiency demands reversibility that no real engine attains. History flirts with reversibility in myths of restoration, yet every cycle completes with hysteresis.'", type: "temporal", quadrant: "temporal", x: 400, y: 200 },
            
            { id: "cybernetic_era", label: "Cybernetic shift: 'With information theory, we discovered that entropy is not thermodynamical, but statistical. The machine is the relational process at play.'", type: "temporal", quadrant: "temporal", x: 300, y: 300 },
            
            { id: "computational_crisis", label: "Computational temporality: 'The future arrives before the present. Predictive systems and financial instruments craft today out of tomorrow, preempting what has not yet occurred.'", type: "temporal", quadrant: "temporal", x: 150, y: 250 },
            
            { id: "presentism", label: "Regime of presentism: 'The horizon of expectation contracts into a permanent now, history and future alike subordinated to an eternal present tense.'", type: "temporal", quadrant: "temporal", x: 200, y: 400 },
            
            { id: "occupation_time", label: "Work as occupation: 'Activity without ends, continuous absorption that suspends the distinction between labor and leisure, between production and display.'", type: "temporal", quadrant: "temporal", x: 350, y: 350 },
            
            // EPISTEMIC MUTATIONS (Top-Right Quadrant)
            { id: "steam_episteme", label: "Steam's conceptual revolution: 'The steam engine forced a revolution in the very concept of work and energy, expanding definition from simple mechanics to universal principle of thermodynamics.'", type: "epistemic", quadrant: "epistemic", x: 1000, y: 150 },
            
            { id: "freud_machine", label: "Psyche as steam engine: 'Freud's whole discussion revolves around that question: what, in terms of energy, is the psyche? The mind became a pressure system—drives, repression, release.'", type: "epistemic", quadrant: "epistemic", x: 1150, y: 250 },
            
            { id: "lacan_language", label: "Language as machine: 'The unconscious concerns the living dynamic of language itself, and language can be thought of as a literal machine. What we call unconscious is language.'", type: "epistemic", quadrant: "epistemic", x: 900, y: 300 },
            
            { id: "infrastructure_pedagogy", label: "Technologies teach: 'Technologies teach us how to imagine ourselves. The boiler gives us the energetic unconscious; statistical engines sponsor a subject of prediction and prompt.'", type: "epistemic", quadrant: "epistemic", x: 1200, y: 350 },
            
            { id: "razi_distinction", label: "Al-Razi's epistemology: 'We can know that a techne like the steam engine transforms society (general knowledge), but cannot fully know what it is in its totality without ethical deliberation.'", type: "epistemic", quadrant: "epistemic", x: 950, y: 200 },
            
            { id: "suhrawardi_illumination", label: "Suhrawardi's paths: 'There are two paths: reasoning and reading of signs, and a direct way whereby truth illuminates us through mystical experience, where subject, object, and knowledge coincide.'", type: "epistemic", quadrant: "epistemic", x: 1100, y: 400 },
            
            // RECURSIVITY PROBLEM (Bottom-Left Quadrant)
            { id: "recursion_beginning", label: "Circular causation: 'Where does recursion begin? The search for the beginning is a search for first cause. In a circular loop, the beginning is only temporal. The cause is the totality of the loop.'", type: "recursive", quadrant: "recursive", x: 200, y: 650 },
            
            { id: "spiral_process", label: "Recursivity as spiral: 'Recursivity ought to be understood not as mere repetition, but as a process of reflexivity in which contingency might emerge and create singularities.'", type: "recursive", quadrant: "recursive", x: 350, y: 750 },
            
            { id: "triple_helix_mutation", label: "Systemic reconfiguration: 'A generative mutation in one strand inevitably forces a reconfiguration of the others. The steam engine forced society and nature to be reconceived through thermodynamic lens.'", type: "recursive", quadrant: "recursive", x: 400, y: 600 },
            
            { id: "actual_before_conceptual", label: "Technology precedes theory: 'The engine was actual before becoming conceptual. Technics made what science later came to better understand. The world became thermodynamical before knowing so.'", type: "recursive", quadrant: "recursive", x: 250, y: 800 },
            
            { id: "helical_cycles", label: "Historical hysteresis: 'Cycles remain, but they are helical cycles—recurrences displaced along an axis of irretrievable transformation. The path back is not the path out.'", type: "recursive", quadrant: "recursive", x: 150, y: 700 },
            
            { id: "entropy_constitution", label: "Waste as constitutive: 'No conversion is free. Entropy is not afterthought: waste heat is constitutive. Each historical advance generates its externalities—the helix advances by spending itself.'", type: "recursive", quadrant: "recursive", x: 300, y: 550 },
            
            // ANTI-CAPTURE STRATEGIES (Bottom-Right Quadrant)
            { id: "metabolic_rift", label: "Metabolic rift: 'When residues are enclosed by platforms, IP regimes, or markets, the cultural cycle suffers metabolic rift: outputs no longer fertilize collective reasoning.'", type: "anticapture", quadrant: "anticapture", x: 1000, y: 650 },
            
            { id: "return_vector", label: "Return vs capture: 'The metabolic force of artistic residue depends on its return vector to the general intellect. Anti-capture design keeps residues circulating as public nutrients.'", type: "anticapture", quadrant: "anticapture", x: 1200, y: 750 },
            
            { id: "nomadic_sedentary", label: "Nomadic vs sedentary: 'Nomadic epistemology is characterized by fluidity, alterity, customary knowledge. Sedentary paradigm is founded on archives, fixed identities, state control, universal reason.'", type: "anticapture", quadrant: "anticapture", x: 900, y: 600 },
            
            { id: "open_processes", label: "Protocol transparency: 'Open processes, composable toolchains, provenance credentials that block commodification while preserving pedagogy become integral to inhuman labor itself.'", type: "anticapture", quadrant: "anticapture", x: 1100, y: 800 },
            
            { id: "recollective_rationality", label: "Recollective media: 'What if technological assemblage were engineered not merely to store memory, but to structure it as tool for reason? History as propositions to be rationally reconstructed.'", type: "anticapture", quadrant: "anticapture", x: 950, y: 750 },
            
            { id: "leaks_matter", label: "Productive leaks: 'Engines leak: heat, steam, noise, time. Some of most consequential innovations are re-routings of the leak—capturing waste heat, revaluing idleness as study.'", type: "anticapture", quadrant: "anticapture", x: 1150, y: 550 }
        ];

        const links = [
            // Temporal flows
            { source: "steam_era", target: "cybernetic_era", type: "temporal" },
            { source: "cybernetic_era", target: "computational_crisis", type: "temporal" },
            { source: "computational_crisis", target: "presentism", type: "temporal" },
            { source: "presentism", target: "occupation_time", type: "temporal" },
            { source: "thermodynamic_time", target: "helical_cycles", type: "temporal" },
            
            // Epistemic shifts
            { source: "steam_episteme", target: "freud_machine", type: "epistemic" },
            { source: "freud_machine", target: "lacan_language", type: "epistemic" },
            { source: "lacan_language", target: "infrastructure_pedagogy", type: "epistemic" },
            { source: "razi_distinction", target: "suhrawardi_illumination", type: "epistemic" },
            { source: "steam_episteme", target: "razi_distinction", type: "epistemic" },
            
            // Recursive loops
            { source: "recursion_beginning", target: "spiral_process", type: "recursive" },
            { source: "spiral_process", target: "triple_helix_mutation", type: "recursive" },
            { source: "actual_before_conceptual", target: "steam_era", type: "recursive" },
            { source: "triple_helix_mutation", target: "entropy_constitution", type: "recursive" },
            { source: "helical_cycles", target: "recursion_beginning", type: "recursive" },
            
            // Anti-capture resistance
            { source: "metabolic_rift", target: "return_vector", type: "anticapture" },
            { source: "return_vector", target: "open_processes", type: "anticapture" },
            { source: "nomadic_sedentary", target: "recollective_rationality", type: "anticapture" },
            { source: "leaks_matter", target: "entropy_constitution", type: "anticapture" },
            { source: "open_processes", target: "leaks_matter", type: "anticapture" },
            
            // Cross-quadrant connections
            { source: "engine", target: "recursion_beginning", type: "connection" },
            { source: "engine", target: "steam_episteme", type: "connection" },
            { source: "engine", target: "computational_crisis", type: "connection" },
            { source: "engine", target: "return_vector", type: "connection" },
            
            // Inter-quadrant flows
            { source: "steam_era", target: "steam_episteme", type: "connection" },
            { source: "actual_before_conceptual", target: "steam_episteme", type: "connection" },
            { source: "infrastructure_pedagogy", target: "computational_crisis", type: "connection" },
            { source: "occupation_time", target: "metabolic_rift", type: "connection" },
            { source: "entropy_constitution", target: "leaks_matter", type: "connection" },
            { source: "suhrawardi_illumination", target: "nomadic_sedentary", type: "connection" }
        ];

        // Get SVG element
        const svg = document.getElementById('network');
        const width = 1400;
        const height = 1000;

        // Create node lookup for links
        const nodeMap = {};
        nodes.forEach(node => nodeMap[node.id] = node);

        // Store links data globally for updates
        window.linksData = links;
        window.nodeGroups = new Map();

        // Estimate text dimensions and set box sizes
        nodes.forEach(node => {
            const fontSize = node.type === "engine" ? 14 : 9;
            const maxWidth = node.type === "engine" ? 120 : 280;
            const lines = wrapText(node.label, maxWidth / (fontSize * 0.6));
            node.width = Math.min(maxWidth, Math.max(...lines.map(line => line.length * fontSize * 0.6))) + 20;
            node.height = lines.length * fontSize * 1.2 + 20;
            node.lines = lines;
        });

        function wrapText(text, maxCharsPerLine) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (let word of words) {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                if (testLine.length <= maxCharsPerLine) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);
            return lines;
        }

        // Draw quadrant dividers
        function drawQuadrants() {
            // Vertical line
            const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            vLine.setAttribute('x1', width/2);
            vLine.setAttribute('y1', 50);
            vLine.setAttribute('x2', width/2);
            vLine.setAttribute('y2', height-50);
            vLine.setAttribute('class', 'axis-line');
            svg.appendChild(vLine);
            
            // Horizontal line
            const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            hLine.setAttribute('x1', 50);
            hLine.setAttribute('y1', height/2);
            hLine.setAttribute('x2', width-50);
            hLine.setAttribute('y2', height/2);
            hLine.setAttribute('class', 'axis-line');
            svg.appendChild(hLine);
            
            // Quadrant labels
            const labels = [
                { text: "TEMPORAL REGIMES", x: width/4, y: 30 },
                { text: "EPISTEMIC MUTATIONS", x: 3*width/4, y: 30 },
                { text: "RECURSIVITY PROBLEM", x: width/4, y: height-20 },
                { text: "ANTI-CAPTURE STRATEGIES", x: 3*width/4, y: height-20 }
            ];
            
            labels.forEach(label => {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', label.x);
                text.setAttribute('y', label.y);
                text.setAttribute('class', 'quadrant-label');
                text.textContent = label.text;
                svg.appendChild(text);
            });
        }

        // Draw links
        function drawLinks() {
            links.forEach(link => {
                const sourceNode = nodeMap[link.source];
                const targetNode = nodeMap[link.target];
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dr = Math.sqrt(dx * dx + dy * dy) * 1.2;
                const pathData = `M${sourceNode.x},${sourceNode.y}A${dr},${dr} 0 0,1 ${targetNode.x},${targetNode.y}`;
                
                path.setAttribute('d', pathData);
                path.setAttribute('class', `link link-${link.type}`);
                svg.appendChild(path);
            });
        }

        // Draw nodes
        function drawNodes() {
            nodes.forEach(node => {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'node');
                group.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                group.setAttribute('data-node-id', node.id);
                
                // Store reference for easy access
                window.nodeGroups.set(node.id, group);
                
                // Rectangle
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', -node.width/2);
                rect.setAttribute('y', -node.height/2);
                rect.setAttribute('width', node.width);
                rect.setAttribute('height', node.height);
                rect.setAttribute('class', `node-rect node-${node.type}`);
                group.appendChild(rect);
                
                // Text
                node.lines.forEach((line, i) => {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('y', (i - (node.lines.length-1)/2) * (node.type === "engine" ? 16 : 11));
                    text.setAttribute('class', `node-text ${node.type === "engine" ? "node-text-engine" : ""}`);
                    text.textContent = line;
                    group.appendChild(text);
                });
                
                // Add drag behavior
                let isDragging = false;
                let startX, startY, offsetX, offsetY;
                
                function onMouseDown(e) {
                    isDragging = true;
                    const rect = svg.getBoundingClientRect();
                    startX = e.clientX - rect.left;
                    startY = e.clientY - rect.top;
                    offsetX = startX - node.x;
                    offsetY = startY - node.y;
                    group.classList.add('dragging');
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                function onMouseMove(e) {
                    if (!isDragging) return;
                    const rect = svg.getBoundingClientRect();
                    const newX = e.clientX - rect.left - offsetX;
                    const newY = e.clientY - rect.top - offsetY;
                    
                    // Constrain to boundaries
                    node.x = Math.max(node.width/2 + 50, Math.min(width - node.width/2 - 50, newX));
                    node.y = Math.max(node.height/2 + 50, Math.min(height - node.height/2 - 50, newY));
                    
                    group.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                    updateLinks();
                    e.preventDefault();
                }
                
                function onMouseUp(e) {
                    if (!isDragging) return;
                    isDragging = false;
                    group.classList.remove('dragging');
                    e.preventDefault();
                }
                
                // Add event listeners to the group
                group.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                
                // Prevent text selection
                group.addEventListener('selectstart', e => e.preventDefault());
                
                svg.appendChild(group);
            });
        }

        function updateLinks() {
            const linkElements = svg.querySelectorAll('.link');
            linkElements.forEach((linkElement, i) => {
                const linkData = window.linksData[i];
                const sourceNode = nodeMap[linkData.source];
                const targetNode = nodeMap[linkData.target];
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dr = Math.sqrt(dx * dx + dy * dy) * 1.2;
                const pathData = `M${sourceNode.x},${sourceNode.y}A${dr},${dr} 0 0,1 ${targetNode.x},${targetNode.y}`;
                linkElement.setAttribute('d', pathData);
            });
        }

        // Initialize diagram
        drawQuadrants();
        drawLinks();
        drawNodes();

        // Global functions
        window.resetAllNodes = function() {
            nodes.forEach(node => {
                if (node.quadrant === "temporal") {
                    node.x = width/4 + (Math.random() - 0.5) * 200;
                    node.y = height/4 + (Math.random() - 0.5) * 200;
                } else if (node.quadrant === "epistemic") {
                    node.x = 3*width/4 + (Math.random() - 0.5) * 200;
                    node.y = height/4 + (Math.random() - 0.5) * 200;
                } else if (node.quadrant === "recursive") {
                    node.x = width/4 + (Math.random() - 0.5) * 200;
                    node.y = 3*height/4 + (Math.random() - 0.5) * 200;
                } else if (node.quadrant === "anticapture") {
                    node.x = 3*width/4 + (Math.random() - 0.5) * 200;
                    node.y = 3*height/4 + (Math.random() - 0.5) * 200;
                } else {
                    node.x = width/2;
                    node.y = height/2;
                }
                
                node.x = Math.max(node.width/2 + 50, Math.min(width - node.width/2 - 50, node.x));
                node.y = Math.max(node.height/2 + 50, Math.min(height - node.height/2 - 50, node.y));
            });
            
            // Redraw everything
            svg.innerHTML = '';
            window.nodeGroups.clear();
            drawQuadrants();
            drawLinks();
            drawNodes();
        };

        window.exportText = function() {
            try {
                const contentNodes = nodes.filter(d => d.type !== 'engine');
                
                const categorizeByPosition = (node) => {
                    const isLeft = node.x < width/2;
                    const isTop = node.y < height/2;
                    
                    if (isTop && !isLeft) return 'epistemic';
                    if (!isTop && !isLeft) return 'anticapture';
                    if (!isTop && isLeft) return 'recursive';
                    if (isTop && isLeft) return 'temporal';
                    return 'center';
                };

                const quadrantGroups = {
                    'epistemic': [],
                    'anticapture': [],
                    'recursive': [],
                    'temporal': []
                };

                contentNodes.forEach(node => {
                    const currentQuadrant = categorizeByPosition(node);
                    if (quadrantGroups[currentQuadrant]) {
                        quadrantGroups[currentQuadrant].push(node);
                    }
                });

                Object.keys(quadrantGroups).forEach(quadrant => {
                    quadrantGroups[quadrant].sort((a, b) => {
                        if (Math.abs(a.y - b.y) < 50) {
                            return a.x - b.x;
                        }
                        return a.y - b.y;
                    });
                });

                const quadrantNames = {
                    'epistemic': 'EPISTEMIC MUTATIONS',
                    'anticapture': 'ANTI-CAPTURE STRATEGIES', 
                    'recursive': 'RECURSIVITY PROBLEM',
                    'temporal': 'TEMPORAL REGIMES'
                };

                let textContent = "RECURSIVE TEMPORALITIES: EPISTEMIC MUTATIONS & ANTI-CAPTURE STRATEGIES\n";
                textContent += "=" + "=".repeat(70) + "\n\n";
                textContent += "Framework: This document reflects the current spatial arrangement of concepts as positioned in the interactive diagram.\n\n";

                const quadrantOrder = ['temporal', 'epistemic', 'recursive', 'anticapture'];
                
                quadrantOrder.forEach(quadrant => {
                    const nodes = quadrantGroups[quadrant];
                    
                    textContent += quadrantNames[quadrant] + "\n";
                    textContent += "-".repeat(quadrantNames[quadrant].length) + "\n";
                    
                    if (nodes.length > 0) {
                        textContent += `(${nodes.length} concepts arranged in this quadrant)\n\n`;
                        
                        nodes.forEach((node, index) => {
                            const cleanText = node.label.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
                            textContent += `${index + 1}. ${cleanText}\n\n`;
                        });
                    } else {
                        textContent += "(No concepts currently positioned in this quadrant)\n\n";
                    }
                    
                    textContent += "\n";
                });

                const currentDate = new Date().toLocaleDateString();
                const currentTime = new Date().toLocaleTimeString();
                textContent += "\n" + "-".repeat(70) + "\n";
                textContent += `Exported from Recursive Temporalities Diagram on ${currentDate} at ${currentTime}\n`;

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `recursive_temporalities_arrangement_${timestamp}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Visual feedback
                const button = event.target;
                if (button) {
                    const originalText = button.textContent;
                    button.textContent = 'Exported!';
                    button.style.background = '#14aa8c';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '#0064b4';
                    }, 2000);
                }
            } catch (error) {
                console.error('Export error:', error);
                alert('Export failed. Check console for details.');
            }
        };
    </script>
</body>
</html>
